# GHOSTYPE 重构指南

## 一、重构前的准备工作

### 1.1 代码结构了解

在动手重构之前，必须完成以下了解工作：

#### 核心链路梳理
```
用户按住快捷键 → HotkeyManager 捕获
       ↓
DoubaoSpeechService 录音 + 语音识别
       ↓
AppDelegate.processWithMode() 分发
       ↓
┌─────────────────────────────────────┐
│ polish → DoubaoLLMService.polishWithProfile()
│ translate → DoubaoLLMService.translate()
│ memo → 直接保存到 CoreData
└─────────────────────────────────────┘
       ↓
insertTextAtCursor() 粘贴上屏
       ↓
saveUsageRecord() 记录到 CoreData
```

#### 架构分层
| 层级 | 目录 | 职责 |
|------|------|------|
| App 入口 | AIInputMethodApp.swift | 应用生命周期、AppDelegate |
| Features | Features/AI/ | LLM服务、Prompt构建、润色配置 |
| Features | Features/Dashboard/ | ViewModel层、状态管理、数据持久化 |
| Features | Features/Settings/ | 全局设置、本地化 |
| Features | Features/Hotkey/ | 快捷键监听 |
| Features | Features/Speech/ | 语音识别服务 |
| Features | Features/Accessibility/ | 光标管理、焦点监听 |
| Features | Features/Permissions/ | 权限管理 |
| UI | UI/Dashboard/ | Dashboard主界面、页面、组件 |
| UI | UI/ | Overlay、Onboarding等窗口 |

#### 依赖关系图
重构前必须画出或理解：
- 哪些类依赖 AppDelegate
- 哪些类被多处引用
- 哪些是单例
- 哪些有循环依赖

### 1.2 问题识别清单

重构时需要识别的问题类型：

#### 🔴 严重问题（必须修复）
- **God Class**: 单个类超过 300 行，职责超过 3 个
- **安全漏洞**: API Key 硬编码、敏感信息明文存储
- **重复代码**: 相同逻辑出现在多处

#### 🟠 中等问题（应该修复）
- **数据流混乱**: 双向绑定、循环更新
- **魔法数字**: 散落在代码各处的常量
- **命名不一致**: 同一概念多种命名

#### 🟡 轻微问题（可以修复）
- **注释语言混杂**: 中英文混用
- **文件位置不当**: 测试文件混入源码
- **组件重复定义**: 功能相似的组件未统一

---

## 二、重构原则

### 2.1 等效性原则

**重构后的逻辑必须与原逻辑完全等效**

验证方法：
1. 单元测试覆盖核心逻辑
2. 手动测试完整用户流程
3. 对比重构前后的输入输出

### 2.2 小步快跑原则

**每次只改一件事，改完立即验证**

错误做法：
```
一次性重构 5 个文件 → 编译失败 → 不知道哪里出错
```

正确做法：
```
改 1 个文件 → 编译 → 测试 → 提交 → 改下一个
```

### 2.3 备份原则

**重构前必须备份原文件**

备份策略：
```
AIInputMethod/
├── Backups/
│   ├── 2026-02-08_AppDelegate.swift
│   ├── 2026-02-08_DoubaoLLMService.swift
│   └── ...
```

或者使用 Git：
```bash
git stash  # 保存当前修改
git checkout -b refactor/phase-1  # 创建重构分支
```

### 2.4 向后兼容原则

**不能改变现有 API 接口**

如果必须改接口：
1. 先添加新接口
2. 标记旧接口为 deprecated
3. 迁移所有调用方
4. 最后删除旧接口

---

## 三、重构步骤模板

### 3.1 提取类/方法

```
1. 确定要提取的代码边界
2. 创建新文件/新方法
3. 复制代码到新位置
4. 编译，修复依赖问题
5. 在原位置调用新代码
6. 编译，测试
7. 删除原位置的重复代码
8. 最终测试
```

### 3.2 替换实现

```
1. 创建新实现（不删除旧实现）
2. 添加切换开关（Feature Flag）
3. 测试新实现
4. 逐步切换到新实现
5. 确认无问题后删除旧实现
```

### 3.3 统一接口

```
1. 定义统一的 Protocol
2. 让现有类实现 Protocol
3. 修改调用方使用 Protocol 类型
4. 提取公共逻辑到基类
5. 子类继承基类
```

---

## 四、常见陷阱

### 4.1 循环引用

Swift 中常见的循环引用场景：
- delegate 模式忘记用 weak
- closure 捕获 self 忘记用 [weak self]
- 双向持有

检查方法：
```swift
deinit {
    print("\(Self.self) deinit")  // 如果不打印，说明有循环引用
}
```

### 4.2 响应式更新丢失

使用 @Observable 时：
- 属性必须是 var，不能是 let
- 计算属性不会触发更新
- 嵌套对象需要也是 @Observable

### 4.3 线程安全

涉及多线程的代码：
- 录音回调在后台线程
- UI 更新必须在主线程
- CoreData 有自己的线程模型

### 4.4 Keychain 沙盒问题

- App Sandbox 开启时，Keychain 访问受限
- 需要配置 Entitlements
- 开发环境和生产环境行为可能不同

---

## 五、验证清单

### 5.1 每次修改后

- [ ] 编译通过
- [ ] 无新增警告
- [ ] 相关单元测试通过

### 5.2 每个 Phase 完成后

- [ ] 完整功能回归测试
- [ ] 录音 → AI → 上屏 流程正常
- [ ] Dashboard 各页面正常
- [ ] 设置保存/读取正常
- [ ] 语言切换正常

### 5.3 全部完成后

- [ ] 代码行数统计（AppDelegate < 100 行）
- [ ] 无硬编码 API Key
- [ ] 无散落的魔法数字
- [ ] 所有页面已本地化
- [ ] 文档更新

---

## 六、重构优先级

按风险和收益排序：

| 优先级 | 任务 | 风险 | 收益 |
|--------|------|------|------|
| P0 | 移除硬编码 API Key | 低 | 高（安全） |
| P1 | 集中魔法数字 | 低 | 中（可维护） |
| P2 | 拆分 AppDelegate | 高 | 高（可测试） |
| P3 | 统一 LLM 服务 | 中 | 中（可扩展） |
| P4 | 整理数据流 | 中 | 中（可维护） |
| P5 | 完善本地化 | 低 | 低（用户体验） |

---

## 七、专家思维模式

一个优秀的重构者会这样思考：

### 7.1 先问为什么

- 为什么要重构这段代码？
- 重构后能解决什么问题？
- 不重构会有什么后果？

### 7.2 先画后写

- 先画出目标架构图
- 再规划迁移路径
- 最后才动手写代码

### 7.3 先测后改

- 先写测试覆盖现有逻辑
- 再进行重构
- 测试保证等效性

### 7.4 先小后大

- 先从最小的、最独立的模块开始
- 积累经验和信心
- 再处理核心复杂模块

### 7.5 先可逆后不可逆

- 先做可以轻松回滚的修改
- 确认稳定后再做不可逆的修改
- 保持随时可以回退的能力
