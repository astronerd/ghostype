import Foundation
import AppKit

// MARK: - Text Insertion Service

/// 文本插入服务
/// 从 AppDelegate 提取的文本插入逻辑，负责剪贴板→粘贴→自动回车
class TextInsertionService {

    // MARK: - NSPasteboard Transient Type (nspasteboard.org standard)

    /// 标记剪贴板内容为临时数据，剪贴板历史工具不应记录
    private static let transientType = NSPasteboard.PasteboardType("org.nspasteboard.TransientType")
    /// 标记剪贴板内容为程序自动生成，非用户主动复制
    private static let autoGeneratedType = NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")

    // MARK: - Public API

    /// 将文本插入到当前光标位置
    func insert(_ text: String) {
        print("[Insert] ========== INSERTING ==========")
        print("[Insert] Text: \(text)")

        guard !text.isEmpty else {
            print("[Insert] Empty text, skipping")
            return
        }

        // 不再做二次 ContextDetector 检测
        // 调用方（SkillExecutor / VoiceInputCoordinator）已经决定要插入文本
        // 这里直接执行剪贴板粘贴，避免 Overlay 窗口干扰 AX 焦点检测

        let frontAppBundleId = NSWorkspace.shared.frontmostApplication?.bundleIdentifier
        let shouldAutoEnter = AppSettings.shared.shouldAutoEnter(for: frontAppBundleId)
        let sendMethod = AppSettings.shared.sendMethod(for: frontAppBundleId)
        FileLogger.log("[Insert] Front app: \(frontAppBundleId ?? "unknown"), Auto-enter: \(shouldAutoEnter), Method: \(sendMethod.rawValue)")

        let pasteboard = NSPasteboard.general

        // 1. 备份当前剪贴板内容（按 type 逐个保存）
        let backup = backupPasteboard(pasteboard)
        FileLogger.log("[Insert] Clipboard backed up (\(backup.count) items)")

        // 2. 写入要粘贴的文本 + TransientType 标记
        pasteboard.clearContents()
        pasteboard.setString(text, forType: .string)
        pasteboard.setData(Data(), forType: Self.transientType)
        pasteboard.setData(Data(), forType: Self.autoGeneratedType)
        let changeCountAfterWrite = pasteboard.changeCount
        FileLogger.log("[Insert] Clipboard set with TransientType, changeCount: \(changeCountAfterWrite)")

        DispatchQueue.main.asyncAfter(deadline: .now() + AppConstants.TextInsertion.clipboardPasteDelay) { [weak self] in
            print("[Insert] Sending Cmd+V...")
            let source = CGEventSource(stateID: .hidSystemState)

            if let keyDown = CGEvent(keyboardEventSource: source, virtualKey: 9, keyDown: true) {
                keyDown.flags = .maskCommand
                keyDown.post(tap: .cghidEventTap)
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + AppConstants.TextInsertion.keyUpDelay) {
                if let keyUp = CGEvent(keyboardEventSource: source, virtualKey: 9, keyDown: false) {
                    keyUp.flags = .maskCommand
                    keyUp.post(tap: .cghidEventTap)
                }
                print("[Insert] Paste done")

                // 3. changeCount 轮询恢复剪贴板
                self?.scheduleClipboardRestore(
                    pasteboard: pasteboard,
                    backup: backup,
                    expectedChangeCount: changeCountAfterWrite
                )

                if shouldAutoEnter {
                    self?.sendKey(method: sendMethod)
                }

                print("[Insert] ========== DONE ==========")
            }
        }
    }

    // MARK: - Clipboard Restore (changeCount polling)

    /// 等待目标应用读取剪贴板后恢复原始内容
    /// 策略：最小等待 0.5s 后开始轮询 changeCount，确认没有其他程序写入后恢复
    private func scheduleClipboardRestore(
        pasteboard: NSPasteboard,
        backup: [[(NSPasteboard.PasteboardType, Data)]],
        expectedChangeCount: Int
    ) {
        let minDelay = AppConstants.TextInsertion.clipboardRestoreMinDelay
        let pollInterval = AppConstants.TextInsertion.clipboardRestorePollInterval
        let maxTimeout = AppConstants.TextInsertion.clipboardRestoreMaxTimeout
        let startTime = Date()

        // 先等最小延迟，给目标应用足够时间读取
        DispatchQueue.main.asyncAfter(deadline: .now() + minDelay) { [weak self] in
            self?.pollAndRestore(
                pasteboard: pasteboard,
                backup: backup,
                expectedChangeCount: expectedChangeCount,
                startTime: startTime,
                pollInterval: pollInterval,
                maxTimeout: maxTimeout
            )
        }
    }

    private func pollAndRestore(
        pasteboard: NSPasteboard,
        backup: [[(NSPasteboard.PasteboardType, Data)]],
        expectedChangeCount: Int,
        startTime: Date,
        pollInterval: TimeInterval,
        maxTimeout: TimeInterval
    ) {
        let elapsed = Date().timeIntervalSince(startTime)

        // 如果 changeCount 变了，说明其他程序写了剪贴板，不要覆盖
        if pasteboard.changeCount != expectedChangeCount {
            FileLogger.log("[Insert] Clipboard changed by another app (changeCount: \(pasteboard.changeCount) != \(expectedChangeCount)), skip restore")
            return
        }

        // 超时强制恢复
        if elapsed >= maxTimeout {
            FileLogger.log("[Insert] Clipboard restore timeout (\(String(format: "%.1f", elapsed))s), force restoring")
            restorePasteboard(pasteboard, from: backup)
            return
        }

        // changeCount 没变，说明目标应用已经读完了（或者还没读）
        // 最小延迟已过，可以安全恢复
        FileLogger.log("[Insert] Clipboard restore after \(String(format: "%.1f", elapsed))s")
        restorePasteboard(pasteboard, from: backup)
    }

    // MARK: - Clipboard Backup / Restore

    /// 备份剪贴板所有 items 的所有 types 和 data
    private func backupPasteboard(_ pasteboard: NSPasteboard) -> [[(NSPasteboard.PasteboardType, Data)]] {
        guard let items = pasteboard.pasteboardItems else { return [] }
        var backup: [[(NSPasteboard.PasteboardType, Data)]] = []
        for item in items {
            var itemData: [(NSPasteboard.PasteboardType, Data)] = []
            for type in item.types {
                if let data = item.data(forType: type) {
                    itemData.append((type, data))
                }
            }
            if !itemData.isEmpty {
                backup.append(itemData)
            }
        }
        return backup
    }

    /// 从备份恢复剪贴板内容
    private func restorePasteboard(_ pasteboard: NSPasteboard, from backup: [[(NSPasteboard.PasteboardType, Data)]]) {
        guard !backup.isEmpty else { return }
        pasteboard.clearContents()
        var newItems: [NSPasteboardItem] = []
        for itemData in backup {
            let item = NSPasteboardItem()
            for (type, data) in itemData {
                item.setData(data, forType: type)
            }
            newItems.append(item)
        }
        pasteboard.writeObjects(newItems)
        FileLogger.log("[Insert] Clipboard restored")
    }

    /// 保存使用记录到 CoreData
    func saveUsageRecord(content: String, category: RecordCategory, originalContent: String? = nil, skillId: String? = nil, skillName: String? = nil) {
        let context = PersistenceController.shared.container.viewContext
        let record = UsageRecord(context: context)
        record.id = UUID()
        record.content = content
        record.originalContent = originalContent
        record.category = category.rawValue
        record.skillId = skillId
        record.skillName = skillName
        record.timestamp = Date()
        record.deviceId = DeviceIdManager.shared.deviceId

        if let frontApp = NSWorkspace.shared.frontmostApplication {
            record.sourceApp = frontApp.localizedName ?? "Unknown"
            record.sourceAppBundleId = frontApp.bundleIdentifier ?? ""
        } else {
            record.sourceApp = "Unknown"
            record.sourceAppBundleId = ""
        }
        record.duration = 0

        do {
            try context.save()
            FileLogger.log("[Record] Saved: \(category.rawValue) skill=\(skillName ?? "nil") - \(content.prefix(30))...")
            
            // Memo 同步：保存成功后触发同步
            if category == .memo {
                MemoSyncManager.shared.syncMemo(content: content, timestamp: record.timestamp ?? Date())
            }
        } catch {
            FileLogger.log("[Record] Save error: \(error)")
        }
    }

    // MARK: - Private

    private func sendKey(method: SendMethod) {
        print("[Insert] Sending \(method.displayName) via osascript...")

        DispatchQueue.main.asyncAfter(deadline: .now() + AppConstants.TextInsertion.autoEnterDelay) {
            let script: String
            switch method {
            case .enter:
                script = "tell application \"System Events\" to key code 36"
            case .cmdEnter:
                script = "tell application \"System Events\" to key code 36 using command down"
            case .shiftEnter:
                script = "tell application \"System Events\" to key code 36 using shift down"
            }

            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/usr/bin/osascript")
            process.arguments = ["-e", script]

            do {
                try process.run()
                process.waitUntilExit()
                print("[Insert] \(method.displayName) sent via osascript, exit code: \(process.terminationStatus)")
            } catch {
                print("[Insert] osascript error: \(error)")
            }
        }
    }
}
