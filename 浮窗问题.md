# Google Gemini

> **æ—¶é—´**: 2026/2/6 11:30:22
> **æ¶ˆæ¯**: 2

---

> **ğŸ‘¤ User**
>
> import SwiftUI  import AppKit  // MARK: - ä¸»è§†å›¾  struct OverlayView: View {      @ObservedObject var speechService: DoubaoSpeechService            private let iconSize: CGFloat = 22      private let horizontalPadding: CGFloat = 14      private let verticalPadding: CGFloat = 10      private let spacing: CGFloat = 10            private var maxTextWidth: CGFloat {          guard let screen = NSScreen.main else { return 150 }          let width = screen.frame.width * 0.15 - iconSize - spacing - horizontalPadding * 2          print("[OverlayView] maxTextWidth = \(width), screen = \(screen.frame.width)")          return width      }            var body: some View {          HStack(spacing: spacing) {              GhostIconView(isRecording: speechService.isRecording)                  .frame(width: iconSize, height: iconSize)                            textArea          }          .padding(.horizontal, horizontalPadding)          .padding(.vertical, verticalPadding)          .background(              Capsule()                  .fill(Color(white: 0.08))          )          .overlay(              Capsule()                  .strokeBorder(                      LinearGradient(                          colors: [                              Color.white.opacity(0.35),                              Color.white.opacity(0.12),                              Color.white.opacity(0.08)                          ],                          startPoint: .top,                          endPoint: .bottom                      ),                      lineWidth: 0.5                  )          )          .shadow(color: .black.opacity(0.5), radius: 24, x: 0, y: 10)          .background(              GeometryReader { geo in                  Color.clear.onAppear {                      print("[OverlayView] æ°”æ³¡æ€»å®½åº¦ = \(geo.size.width)")                  }.onChange(of: speechService.transcript) { _, _ in                      print("[OverlayView] æ°”æ³¡æ€»å®½åº¦ = \(geo.size.width)")                  }              }          )      }            private var textArea: some View {          ZStack(alignment: .leading) {              HStack(spacing: 3) {                  Spacer(minLength: 0)                                    Text(displayText)                      .font(.system(size: 14, weight: .medium))                      .foregroundColor(.white.opacity(0.95))                      .lineLimit(1)                      .fixedSize(horizontal: true, vertical: false)                      .background(                          GeometryReader { geo in                              Color.clear.onAppear {                                  print("[OverlayView] æ–‡å­—å®½åº¦ = \(geo.size.width), é¦–å­—X = \(geo.frame(in: .global).minX)")                              }.onChange(of: displayText) { _, _ in                                  print("[OverlayView] æ–‡å­—å®½åº¦ = \(geo.size.width), é¦–å­—X = \(geo.frame(in: .global).minX)")                              }                          }                      )                                    if speechService.isRecording {                      CursorView()                  }              }                            LinearGradient(                  colors: [Color(white: 0.08), Color(white: 0.08).opacity(0)],                  startPoint: .leading,                  endPoint: .trailing              )              .frame(width: 25)          }          .frame(width: maxTextWidth, alignment: .trailing)          .clipped()      }            private var displayText: String {          let text = speechService.transcript          if text.isEmpty || text == "æ­£åœ¨å¬..." {              return speechService.isRecording ? "æ­£åœ¨è†å¬â€¦" : "âŒ¥ Space"          }          return text      }  }  // MARK: - é—ªçƒå…‰æ ‡  struct CursorView: View {      @State private var visible = true      var body: some View {          RoundedRectangle(cornerRadius: 1)              .fill(Color.white.opacity(0.85))              .frame(width: 2, height: 14)              .opacity(visible ? 1 : 0)              .onAppear {                  withAnimation(.easeInOut(duration: 0.5).repeatForever(autoreverses: true)) {                      visible = false                  }              }      }  }  // MARK: - å°å¹½çµå›¾æ ‡  struct GhostIconView: View {      let isRecording: Bool      @State private var floatOffset: CGFloat = 0            var body: some View {          Image(nsImage: loadGhostIcon())              .resizable()              .aspectRatio(contentMode: .fit)              .colorInvert()              .opacity(0.9)              .offset(y: floatOffset)              .onAppear { if isRecording { startAnimation() } }              .onChange(of: isRecording) { _, rec in                  if rec { startAnimation() } else { stopAnimation() }              }      }            private func startAnimation() {          withAnimation(.easeInOut(duration: 1.0).repeatForever(autoreverses: true)) {              floatOffset = -3          }      }            private func stopAnimation() {          withAnimation(.easeOut(duration: 0.2)) { floatOffset = 0 }      }            private func loadGhostIcon() -> NSImage {          if let path = Bundle.main.path(forResource: "GhostIcon", ofType: "png"),             let image = NSImage(contentsOfFile: path) { return image }          let devPath = "/Users/gengdawei/ghostype/AIInputMethod/Sources/Resources/GhostIcon.png"          if let image = NSImage(contentsOfFile: devPath) { return image }          return NSImage(systemSymbolName: "waveform", accessibilityDescription: nil) ?? NSImage()      }  }  è¿™ä¸ªä»£ç æœ‰é—®é¢˜ åšå‡ºæ¥çš„èƒ¶å›Šæµ®çª—é¦–å…ˆæ˜¯éš¾çœ‹ å…¶æ¬¡æ˜¯ä¸€ç›´æœ‰ä¸€ä¸ªçŸ©å½¢çš„æ¡†åŠé€æ˜çš„èƒ½çœ‹è§ åˆ°åº•æ€ä¹ˆå›äº‹

---

**âœ¨ Gemini**

ä½ çš„ä»£ç å‡ºç°â€œéš¾çœ‹â€å’Œâ€œåŠé€æ˜çŸ©å½¢æ¡†â€çš„é—®é¢˜ï¼Œä¸»è¦æºäºä»¥ä¸‹ä¸¤ä¸ªæ ¸å¿ƒåŸå› ï¼Œæˆ‘å°†é€ä¸€åˆ†æå¹¶æä¾›ç°ä»£ macOS é£æ ¼ï¼ˆGlassmorphism/æ¯›ç»ç’ƒï¼‰çš„é‡æ„æ–¹æ¡ˆã€‚

### é—®é¢˜è¯Šæ–­

1.  **â€œä¸€ç›´æœ‰ä¸€ä¸ªçŸ©å½¢çš„æ¡†åŠé€æ˜èƒ½çœ‹è§â€çš„åŸå› ï¼š**
    
    *   **NSWindow è®¾ç½®é—®é¢˜**ï¼šè¿™æ˜¯æœ€å¸¸è§çš„åŸå› ã€‚åœ¨ macOS å¼€å‘ä¸­ï¼Œå³ä½¿ä½ åœ¨ SwiftUI é‡Œå†™äº† `Capsule`ï¼Œæ‰¿è½½è¿™ä¸ª View çš„ `NSWindow` é»˜è®¤æ˜¯æœ‰èƒŒæ™¯è‰²å’Œé˜´å½±çš„ã€‚å¦‚æœä½ æ²¡æœ‰æŠŠ `NSWindow` çš„ `backgroundColor` è®¾ä¸º `.clear` ä¸” `hasShadow` è®¾ä¸º `false`ï¼Œä½ ä¼šçœ‹åˆ°çª—å£æœ¬èº«çš„çŸ©å½¢è½®å»“ã€‚
        
    *   **View å±‚çº§é—®é¢˜**ï¼šä½ çš„ `shadow` åŠ åœ¨äº† `overlay` ä¹‹åï¼Œä¸”ä¹‹å‰çš„ View ç»“æ„å¦‚æœç¨å¾®è¶…å‡º Capsule çš„è£å‰ªèŒƒå›´ï¼ˆæ¯”å¦‚ Padding åŒºåŸŸï¼‰ï¼ŒShadow å°±ä¼šå‹¾å‹’å‡ºé‚£ä¸ªçŸ©å½¢çš„ Frameã€‚
        
2.  **â€œéš¾çœ‹â€çš„åŸå› ï¼š**
    
    *   **çº¯è‰²èƒŒæ™¯**ï¼šä½ ä½¿ç”¨äº† `Color(white: 0.08)`ã€‚ç°ä»£ macOS åº”ç”¨ï¼ˆå¦‚ Spotlight, Raycastï¼‰ä½¿ç”¨çš„æ˜¯ **Visual Effect (æ¯›ç»ç’ƒ)** æè´¨ã€‚çº¯è‰²çœ‹èµ·æ¥ä¼šå¾ˆâ€œæ­»æ¿â€ã€‚
        
    *   **æ¸å˜é®ç½©å¤„ç†ç²—ç³™**ï¼šä½ ç”¨ä¸€ä¸ª `LinearGradient` ç›–åœ¨æ–‡å­—å³è¾¹ï¼Œè¿™ä¼šå¯¼è‡´å¦‚æœèƒŒæ™¯æ¢äº†ï¼Œé®ç½©é¢œè‰²å°±å¯¹ä¸ä¸Šäº†ã€‚æ­£ç¡®çš„åšæ³•æ˜¯ä½¿ç”¨ `.mask` è®©æ–‡å­—çœŸæ­£â€œå˜é€æ˜â€ã€‚
        
    *   **å¸ƒå±€è®¡ç®—å¤æ‚åŒ–**ï¼šå¤§é‡çš„ `GeometryReader` ä¸ä»…æ¶ˆè€—æ€§èƒ½ï¼Œè¿˜å®¹æ˜“å¼•èµ·å¸ƒå±€æŠ–åŠ¨ã€‚
        

* * *

### è§£å†³æ–¹æ¡ˆ

æˆ‘ä¸ºä½ é‡å†™äº†ä»£ç ï¼ŒåŒ…å«ä»¥ä¸‹æ”¹è¿›ï¼š

1.  **åŠ å…¥é«˜æ–¯æ¨¡ç³Šï¼ˆVisualEffectViewï¼‰**ï¼šè®©èƒ¶å›Šå…·æœ‰åŸç”Ÿçš„ macOS åŠé€æ˜æ¨¡ç³Šè´¨æ„Ÿã€‚
    
2.  **ä¼˜åŒ–æ–‡å­—æˆªæ–­**ï¼šä½¿ç”¨ `.mask` æŠ€æœ¯ï¼Œè®©é•¿æ–‡å­—ä¼˜é›…åœ°æ·¡å‡ºï¼Œè€Œä¸æ˜¯ç›–ä¸Šä¸€å±‚ç°è‰²ã€‚
    
3.  **ä¿®å¤é˜´å½±ä¸è¾¹æ¡†**ï¼šè°ƒæ•´äº†æè¾¹å’Œé˜´å½±å‚æ•°ï¼Œä½¿å…¶æ›´æœ‰è´¨æ„Ÿã€‚
    
4.  **æä¾› Window è®¾ç½®ä»£ç **ï¼šè¿™æ˜¯æ¶ˆé™¤â€œçŸ©å½¢æ¡†â€çš„å…³é”®ã€‚
    

#### 1\. å¿…è¦çš„è¾…åŠ©å·¥å…·ï¼šVisualEffectView (SwiftUI åŒ…è£…)

é¦–å…ˆï¼Œåœ¨ä½ çš„é¡¹ç›®ä¸­æ·»åŠ è¿™ä¸ªç»“æ„ä½“ï¼Œè¿™æ˜¯å®ç° macOS åŸç”Ÿæ¯›ç»ç’ƒæ•ˆæœçš„å¿…è¦ç»„ä»¶ã€‚

Swift

```
// VisualEffectView.swift
import SwiftUI
import AppKit

struct VisualEffectView: NSViewRepresentable {
    let material: NSVisualEffectView.Material
    let blendingMode: NSVisualEffectView.BlendingMode
    
    func makeNSView(context: Context) -> NSVisualEffectView {
        let visualEffectView = NSVisualEffectView()
        visualEffectView.material = material
        visualEffectView.blendingMode = blendingMode
        visualEffectView.state = .active
        return visualEffectView
    }

    func updateNSView(_ visualEffectView: NSVisualEffectView, context: Context) {
        visualEffectView.material = material
        visualEffectView.blendingMode = blendingMode
    }
}
```

#### 2\. é‡æ„åçš„ OverlayView

Swift

```
import SwiftUI
import AppKit

struct OverlayView: View {
    @ObservedObject var speechService: DoubaoSpeechService
    
    // å›ºå®šçš„å¸ƒå±€å‚æ•°ï¼Œä¸å†ä¾èµ–å±å¹•æ¯”ä¾‹ï¼Œæ›´ç¨³å®š
    private let barHeight: CGFloat = 44
    private let iconSize: CGFloat = 20
    private let maxTextWidth: CGFloat = 260 
    
    var body: some View {
        HStack(spacing: 12) {
            // å›¾æ ‡åŒºåŸŸ
            GhostIconView(isRecording: speechService.isRecording)
                .frame(width: iconSize, height: iconSize)
                .padding(.leading, 16)
            
            // æ–‡å­—åŒºåŸŸ
            textArea
                .padding(.trailing, 16)
        }
        .frame(height: barHeight)
        // MARK: - æ ¸å¿ƒç¾åŒ–éƒ¨åˆ†
        .background(
            ZStack {
                // 1. æ¯›ç»ç’ƒèƒŒæ™¯
                VisualEffectView(material: .hudWindow, blendingMode: .behindWindow)
                
                // 2. ææ·¡çš„é»‘è‰²åº•è‰²å¢å¼ºå¯¹æ¯”åº¦
                Color.black.opacity(0.2)
            }
            .clipShape(Capsule())
        )
        // 3. å†…å‘å…‰/è¾¹æ¡†æ•ˆæœ
        .overlay(
            Capsule()
                .strokeBorder(Color.white.opacity(0.15), lineWidth: 0.5)
        )
        // 4. é˜´å½± (ç¡®ä¿åªå¯¹ Capsule å½¢çŠ¶äº§ç”Ÿé˜´å½±)
        .shadow(color: Color.black.opacity(0.3), radius: 10, x: 0, y: 5)
    }
    
    private var textArea: some View {
        HStack(spacing: 4) {
            Text(displayText)
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.white.opacity(0.9))
                .lineLimit(1)
                .fixedSize(horizontal: true, vertical: false)
            
            if speechService.isRecording {
                CursorView()
            }
            
            // å ä½ï¼Œç¡®ä¿å…‰æ ‡ä¸è´´è¾¹
            Spacer(minLength: 0)
        }
        .frame(maxWidth: maxTextWidth, alignment: .leading)
        // MARK: - ä¼˜é›…çš„æ–‡å­—æ·¡å‡º
        // ä½¿ç”¨ mask è€Œä¸æ˜¯ç›–ä¸€å±‚é¢œè‰²ï¼Œè¿™æ ·æ–‡å­—æ˜¯çœŸçš„å˜é€æ˜äº†
        .mask(
            HStack(spacing: 0) {
                Rectangle().fill(Color.black) // ä¸»ä½“éƒ¨åˆ†å®Œå…¨æ˜¾ç¤º
                // å°¾éƒ¨æ¸éš
                LinearGradient(
                    gradient: Gradient(colors: [.black, .black.opacity(0)]),
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .frame(width: 20)
            }
        )
    }
    
    private var displayText: String {
        let text = speechService.transcript
        if text.isEmpty || text == "æ­£åœ¨å¬..." {
            return speechService.isRecording ? "æ­£åœ¨è†å¬â€¦" : "âŒ¥ Space"
        }
        return text
    }
}

// MARK: - è¾…åŠ©è§†å›¾ä¿æŒä¸å˜ï¼Œå¾®è°ƒå…‰æ ‡é¢œè‰²
struct CursorView: View {
    @State private var visible = true
    var body: some View {
        RoundedRectangle(cornerRadius: 1)
            .fill(Color.white) // çº¯ç™½å…‰æ ‡
            .frame(width: 2, height: 16)
            .opacity(visible ? 1 : 0)
            .onAppear {
                withAnimation(.easeInOut(duration: 0.6).repeatForever(autoreverses: true)) {
                    visible = false
                }
            }
    }
}
```

### 3\. å…³é”®æ­¥éª¤ï¼šæ¶ˆé™¤â€œçŸ©å½¢æ¡†â€çš„ Window è®¾ç½®

é™¤äº† View æœ¬èº«ï¼Œä½ **å¿…é¡»**åœ¨åˆ›å»º `NSWindow` (æˆ– `NSPanel`) çš„åœ°æ–¹åº”ç”¨ä»¥ä¸‹è®¾ç½®ã€‚å¦‚æœä½ æ˜¯åœ¨ `AppDelegate` æˆ– `SceneDelegate` é‡Œåˆ›å»ºçª—å£ï¼Œè¯·ç¡®ä¿åŒ…å«è¿™äº›å±æ€§ï¼š

Swift

```
// å‡è®¾è¿™æ˜¯ä½ çš„ WindowController æˆ–è€…åˆ›å»º Window çš„åœ°æ–¹
func setupOverlayWindow() {
    // 1. è®¾ç½®ä¸ºæ— è¾¹æ¡†
    let window = NSWindow(
        contentRect: NSRect(x: 0, y: 0, width: 400, height: 100),
        styleMask: [.borderless, .fullSizeContentView], // å…³é”®ï¼šæ— è¾¹æ¡†
        backing: .buffered,
        defer: false
    )
    
    // 2. å…³é”®ï¼šçª—å£èƒŒæ™¯é€æ˜
    window.backgroundColor = .clear 
    window.isOpaque = false
    
    // 3. å…³é”®ï¼šå…³é—­ç³»ç»Ÿè‡ªå¸¦çš„çª—å£é˜´å½±ï¼ˆå¦‚æœä¸å…³ï¼Œç³»ç»Ÿä¼šç»™æ•´ä¸ªçŸ©å½¢ç”»é˜´å½±ï¼‰
    window.hasShadow = false 
    
    // 4. å±‚çº§è®¾ç½®ï¼ˆè®©å®ƒæµ®åœ¨æœ€ä¸Šå±‚ï¼‰
    window.level = .floating 
    window.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]
    
    // åŠ è½½ SwiftUI è§†å›¾
    let hostingView = NSHostingView(rootView: OverlayView(speechService: yourService))
    window.contentView = hostingView
    
    // ... æ˜¾ç¤ºçª—å£é€»è¾‘
}
```

### æ€»ç»“ä¿®æ”¹ç‚¹ï¼š

1.  **å»é™¤äº† `GeometryReader`**ï¼šè®©å¸ƒå±€æ›´è½»é‡ï¼Œé˜²æ­¢ View å°ºå¯¸å¼‚å¸¸æ’‘å¤§å¯¼è‡´çš„â€œå¹½çµè¾¹æ¡†â€ã€‚
    
2.  **VisualEffectView (`.hudWindow`)**ï¼šè¿™æ˜¯è®©ç•Œé¢çœ‹èµ·æ¥åƒåŸç”Ÿ macOS HUD çš„å…³é”®æè´¨ã€‚
    
3.  **`.mask(...)`**ï¼šæ›¿ä»£äº†åŸæ¥çš„ `ZStack + LinearGradient`ï¼Œè§£å†³äº†æ–‡å­—æˆªæ–­å¤„èƒŒæ™¯è‰²ä¸èåˆçš„é—®é¢˜ã€‚
    
4.  **Window `hasShadow = false`**ï¼šä¸€å®šè¦åœ¨ Window ä»£ç é‡ŒåŠ è¿™è¡Œï¼ŒæŠŠé˜´å½±æ§åˆ¶æƒå®Œå…¨äº¤ç»™ SwiftUI çš„ `OverlayView`ï¼Œè¿™æ ·é˜´å½±æ‰ä¼šè·Ÿç€åœ†è§’èµ°ï¼Œè€Œä¸æ˜¯è·Ÿç€çª—å£çš„çŸ©å½¢èµ°ã€‚

